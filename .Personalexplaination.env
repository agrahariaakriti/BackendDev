# in app.js
import userRoutes from "./routes/user.routes.js";
app.use("/api/v1/users", userRoutes);

# from this to go to userRoutes
# user.route.js
import { Router } from "express";
import { registerUser } from "../controllers/user.controllers.js";

const router = Router();

router.route("/register").post(registerUser);

export default router;

# from this to controller registerUser

import { asyncHandler } from "../utils/asyncHandler.js";

const registerUser = asyncHandler(async (req, res, next) => {
  // Registration logic here
  res.status(200).json({
    message: "OK",
  });
});

export { registerUser };
#  to  this ........... Now what exaclty happening internally explanation in simple ad easy way


# Now — the INTERNAL FLOW (this is the key)

# Let’s simulate this request:

# POST /api/v1/users/register

# ✅ Step-by-step internal execution
# STEP 1 — Request reaches Express

# Client → Express server (app)

# STEP 2 — Global middleware runs
# express.json()
# cors()
# cookieParser()


# So now:

# req.body exists

# CORS rules applied

# cookies parsed

# STEP 3 — Express checks mounted paths
# app.use('/api/v1/users', userRoutes);


# Request URL starts with /api/v1/users ✅
# → Forward request to userRoutes

# STEP 4 — Router checks its routes
# router.route("/register").post(registerUser);


# Remaining path is /register
# HTTP method is POST ✅
# → Match found

# STEP 5 — Controller is called
# registerUser(req, res, next)


# Now control is inside your controller

# STEP 6 — asyncHandler wraps the controller
# asyncHandler(async (req, res) => { ... })


# This does ONE important thing:

# catches errors

# forwards them to Express error middleware

# So you don’t need try/catch everywhere.

# STEP 7 — Response is sent
# res.status(200).json({ message: "OK" });


# Express:

# serializes JSON

# sends HTTP response

# closes request

# ✅ Request lifecycle ends here.

# Why controller is separated (non-negotiable reasons)

# If you write logic inside routes:

# ❌ BAD

# router.post('/register', async (req, res) => {
#   // validation
#   // DB call
#   // hashing
# });


# Problems:

# untestable

# duplicated logic

# routes become bloated

# impossible to scale

# ✅ GOOD

# router.post('/register', registerUser);


# Controller:

# reusable

# testable independently

# clean separation

# This is professional backend structure, not optional.

# Mental model (memorize)
# Request
#   ↓
# app (global middleware)
#   ↓
# router (URL matching)
#   ↓
# controller (logic)
#   ↓
# response
